== Welcome to the TurboGears Menu Extension ==

tgext.menu provides a way for controllers to be more easily reused,
while providing developers a way to stop worrying about the menus in
their application. In a nutshell, that is what you get.

One thing that all web applications have in common is the need for
menus to help users navigate the application. The menus can be small,
single level, easily displayed across the top of the page. Or they can
be large, complex, hierarchical, and highly variable depending on
permissions and a whole host of other factors. tgext.menu helps out in
any of these cases.


When you use tgext.menu, you need to do the following three steps:

1. Add it to your project. This is accomplished by modifying your setup.py. Add "tgext.menu" to your **install_requires** list. 

2. Add it to your master template. This step varies depending on whether you are using Mako or Genshi for your templating engine. In either case, where you have the code to render your navigation bar, put this code:

**Mako**

{{{
#!html+mako
${render_navbar()|n}
}}}

**Genshi**

{{{
#!genshi
${HTML(render_navbar())}
}}}

3. Add tgext.menu into your controllers. Place this code in any controllers that will be using tgext.menu:

{{{
#!python
from tgext.menu import navbar, sidebar, menu
}}}

In front of any @expose'd methods, place a call to add them to your navigation bar, like so:

{{{
#!python
@navbar('TestHome')
@expose('genshi:tgext.menu.test.templates.index')
def index(self, *p, **kw):
    return dict()
}}}

To nest menus, use || as separators, like so:

{{{
#!python
@navbar('My || Sub || Menu')
@expose('genshi:tgext.menu.test.templates.index')
def index(self, *p, **kw):
    return dict()
}}}


And that's it, your menus will now render automatically. When you
addmore items to your navbar using @navbar, they will appear without
your having to update any templates at all.

== Full Documentation ==

tgext.menu is built around the idea that a given web application can
have any number of menus. In this extension, each of them are
named. Two are so common that they are given shortcuts in the API:
navbar and sidebar. If you have other menus you wish to add to, you
will need to name them specifically. Fortunately, this is not as hard
as it sounds.


In your controller code, you will be using one of three decorators:

* @navbar('menu path')
* @sidebar('menu path')
* @menu('menu path', 'menu name')

In addition, you may be using one of six functions in your code:

* menu_append('menu path')
* navbar_append('menu path')
* sidebar_append('menu path')
* menu_remove('menu path')
* navbar_remove('menu path')
* sidebar_remove('menu path')

The above functions are meant to allow you to easily add and remove menu
entries programmatically.

The decorators and methods all take a common set of parameters:

* menu path
* permission
* url
* extension

menu path is simply a string of entries, separated by ||, indicating
where this particular entry lives in the menu hierarchy. An example
would be "Help || About" or "Edit || Copy", or "My || Deeply || Nested || Submenu".
Spaces around || will be stripped off, and are only put
in those strings for readability.

permission is the permission to check in order to display this item. It may be
a simple string or a full predicate from repoze.what.

url is the place the menu item points to. It will always be prefixed by the
path to the controller calling any of these methods *unless* the url is an
absolute url (i.e.: it has a ":" in it somewhere).

extension is the file extension to put at the end. The dot will be supplied
for you, so you would only need to add "js" for javascript, for instance.

If you use the @menu decorator or menu_append or menu_remove, you will need to
specify which menu this particular menu entry belongs to. This will allow you
to provide a specific menu for a specific section of your application. An
example would be if you are writing up an admin module, and want to provide an
admin-only menu.

Using @menu will be rare. Normally, you will only be using @navbar or
@sidebar.

Finally, for menu_append, navbar_append, and sidebar_append, you *must* supply
one additional parameter named "base". "base" is the class instance that is
the root of the path to be appended. Typically, this will be "self", though if
you know of another class instance that can be found in the hierarchy, you can
use that instead (of course, if that is appropriate to do). Failure to supply
"base" is an error, and will result in an exception being thrown.

In your template, you will need to render the menu. This follows a
similar pattern from above. You will have the following methods
available to you in your template:

* render_navbar(vertical=False)
* render_sidebar(vertical=False)
* render_menu(menu_name, vertical=False)

The "vertical" parameter is used to tell jdMenu that this should be a vertical
menu.

== Configuration Options ==

In your app_cfg, you may have a section named "base_config.tgext_menu". The
way to add this section is to produce code like this:

{{{
#!python
base_config.tgext_menu = {}
base_config.tgext_menu['inject_css'] = True
}}}

This has three possible parameters in it: inject_css, inject_js and sortorder.

=== inject_css : default False ===

The "inject_css" parameter is used to inject the default CSS that
comes from the [[http://jdsharp.us/jQuery/plugins/jdMenu/|jdMenu
plugin]]. It is set to False,by default, so as to allow you to specify
your own CSS.

=== inject_js : default True ===

The "inject_js" parameter allows you to turn off the javascript. In this case,
you will have just a set of ul/li/a tags in your page representing the menu,
and may do as you see fit with it.

== sortorder: default None ===

"sortorder" is a bit more complex to explain. Basically, using this, you can
set up the sort ordering for your menus. This is done by assigning entries a
numeric value, with higher values going towards the right/bottom, and lower
values towards the left/top. An entry is a single path segment. This is
accomplished by assigning a dictionary to the sortorder configuration
paramter. Unassigned entries will be given a value of 999999. All of this is
best to explain by example.

Assume we have the following menu entries:
ExitApp
Foo Spot || Bar
Foo Spot || Baz
Foo Spot || Foo

Now assume we have set the following dictionary as our sort order:
{ 'ExitApp': 20, 'Foo': 10 }

This will result in the menus being order like so:
ExitApp
Foo Spot || Foo
Foo Spot || Bar
Foo Spot || Baz

'ExitApp' will be compared with 'Foo Spot'. 'Foo Spot' has the value 999999,
and ExitApp has 20. ExitApp goes first.

In the sub menu for 'Foo Spot', 'Foo' has the value 10, while the others have
the value 999999. 'Foo' goes first.

== Drawbacks ==

Adding the code for rendering a Google sitemap should be relatively
easy. However, it has not been done as yet.


== Doc To-Do Items ==

 * Document how to use call backs
 * Document how to get a specific link marked with the CSS class active in
   the rendered output
 * Document how to add arbitrary attributes to a menu item
 * Document why '@require' cannot be honored automatically, and the
   workaround for it
 * Document the code internally
